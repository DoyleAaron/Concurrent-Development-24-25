## License 
##### Copyright (C) 2024 Mr. Aaron Doyle. This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public Licensealong with this program.  If not, see <http://www.gnu.org/licenses/>.

## Objectives
##### The objective of this assignment is to be able to provide a working version of the Wa-Tor simulation with Sharks and Fish interacting as expected in the documentation

## Issues & how I solved them
##### The first big issue I ran into was how to randomise the layout of the grid initially. The solution that I found for this was by entering all of the sharks and fish into a grid the size of the simulation and then using rand.shuffle to jumble up the order that they were being displayed in. ChatGPT gave me this idea and then I researched how it works from here (https://pkg.go.dev/math/rand#Shuffle) as well

##### The next big issue that I ran into was how to get the sharks and fish moving. This issue was solved by using a formula that was generated by ChatGPT for the area to the north,south,east and west of the current fish/shark which I could then assign the fish/shark value to the correct value depending on what was in that area.

##### The next issue I faced in building this simulation is that I dont think the fish are being handled correctly asthey just disappear immediately. This ended up being due to how I was storing the grid as I wasn't copying it correctly which caused them to flash up for a second and then disappear.

##### The next issue I faced is that the sharks aren't dying once they hit their starvation point. This was due to the fact that I didn't check if it was less than the value of 0 and I added in the continue keyword so that it would skip the rest of the logic for the sharks if it had already starved.

##### After doing this I moved on to getting the fish to move as currently they were just static on the screen. The fish would follow the same movement and bredding logic but they do not starve so they are a bit more simple to implement. The issue I am now running into is that the fish seem to reproduce very quickly and the sharks seem to die off quite quickly. I was accidentally not resetting the starve timers for the sharks which was making them all just despawn after a certain amount of time, this led to the fish dominating every simulation that I ran.

##### I have now spotted a small issue where the shaks are starving very quickly. I am still working on this issue but I have now seeded a randomness so I get the same random input every time as this was making the simulation very imbalanced and hard to make even before. I have finally fixed this issue, there was a tiny logic error in the way I was dealing with my 2 grids so this led to them becoming desynchronised. After speaking with Joe we finally found this issue an came to the solution of instead using a singular grid to remove the possibility of any sync issues and use a visited check to mark all the cells that had already been visited in this iteration so they couldn't be overwritten.

##### I finally got the one threaded version working, this took a lot of playing around with the grids and movement/breeding logic to finally get working but I did manage to do it. This is now working fully as expected

### Two Threaded Version

##### My first issue was figuring out how to split my grid up into different parts, I did use ChatGPT for part of this but I eventually got both threads working independantly after a lot of crashing on startup. 

##### My next and biggest issue that I had to solve was how to make sharks and fish pass through from one thread to another safely, for this I used a Mutex lock. This actually ended up working incredibly well. What I did was make a check to see if a fish's next movement was going to be in the next thread and then I put a mutex lock around my struct to allow me to make sure that only one thing could move into that square at a time. This did take a bit of tinkering with but after I figured out how to structure it by locking it, completing the logic and then unlocking it once it was done, it worked very nicely and gave me my two threaded version.

### Four & Eight Threaded Version

##### The four and eight threaded versions weren't too bad to implement as they follow the exact same logic as the two threaded version except this time I just added more partitions in the simulation so each of them would have their own thread, the two threaded logic worked perfectly for this and that is how I implemented these versions.

### Performance Monitoring

##### I have documented my findings in the Jupyter Notebook that I created but all I am doing to monitor this is running each of them for 30 seconds and storing the FPS every second into a CSV which I am then grpahing and noting my takes on the findings. I have used Jupyter notebooks with graphing before so this wasn't too bad to build.


## Running The Docs

##### I have my docs running in go doc for the single threaded version, all functions etc are the same here except they are abstracted out into different files due to issues with go doc, I only have this for the single threaded version as I was running into weird errors when trying to abstract the multi threaded version which was breaking the simulation, however the functions are the same and do mainly follow a similar logic, it is all still commented in the correct format in the code so you are able to use go doc *function name* to see the comments for those functions as they would appear in the go doc. The command that I used to run the go doc locally on my machine is $(go env GOPATH)/bin/godoc -http=:6060 . This command made the go doc run locally on my localhost however I have also provided screenshots in the WaTor folder of them as well. I have also included the html file for the docs if you wish to run that instead.

## Running The Code

##### To be able to run the code for each of versions, if you navigate to the folder where the wator file is and then use the command go run *file name* the file then should run as expected. If necessary you can use go build *package name* to build the files if needed, the jupyter notebook already has my findings outline in it so that shouldn't need to be run again.